
2021winter-python中内秀治151-003202-5
2021winter-python中内秀治151-003202-5_
Table of contents
1 Python 入門
1.1 はじめに
1.2 資料
2 文字列を入力させて表示
3 繰返しとブロックの概念
3.1 ブロック
3.2 入力した言葉を繰り返して表示
3.3 繰返しながら途中を表示
3.4 数を入力して、その回数計算
3.5 入力に応じて動作を変える
4 繰り返し
実習
新しいセクション
5 素数判定プログラム
5.1 単純な判定方法の利用
5.2 判定方法を変える
問題
6 ユークリッドの互除法
7 リスト
7.1.1 リストの長さ
リストからグラフ
8 エラトステネスのふるい
9 関数定義
10 乱数の利用
10.1 確率を利用したゲーム
10.2 近似値の計算
10.3 図示
問題
11 探索の手順とプログラム
11.1 線形探索
線形探索の計算量
11.2 二分探索
二分探索のプログラム
二分探索を Pythonで書く
二分探索の手間を評価する
12 整列の手順とプログラム
準備：値を交換する手順
12.1 選択ソート
選択ソート法のアルゴリズムの記述
選択ソートの計算の手間
問題
【注意】Pythonの内部関数を利用した整列
13 ハノイの塔
13.1 手順
13.2 手順を部品にする
13.3 再帰呼出し
問題
14 クイックソート
14.1 クイックソートの手順
14.2 Python でクイックソート
14.3 クイックソートの計算の手間
問題
15 放物運動のシミュレーション（情報処理学会MOOC教材より転載）
16 統計処理
16.1 基本的な関数
16.1.1 最大値と最小値
16.1.2 和
16.1.3 平均と中央値
16.2 分散と標準偏差
16.3 相関係数
16.4 データの順位
16.5 演習
17 データ分析とグラフ
17.1棒グラフ
17.2. 折れ線グラフ
離散空間上の線形計画問題
17.3. 散布図
18 WebAPI （情報処理学会MOOC教材より転載）
19 データの活用 （情報処理学会MOOC教材より転載）
20 COVID-19 のオープンデータの可視化
練習1
21 地図とオープンデータの利用
22 メルカトル図法地図を球体にする
解答編
1 Python 入門
1.1 はじめに
これは、Google Colaboratory で作成された Python の教材かつノートブックです。
左上の「ファイル」を開いて、「コピーを保存」をしてください。
自分のGoogleドライブに、そのファイルが保存されます。それを利用して学習・演習を進めて下さい。
実行する前に、次の準備をして下さい。
右上の歯車アイコンを開く
出てきたメニューの左「エディタ」タブを開く
「行番号を表示」をチェックする。その他適宜、使いやすいように自分の好みでチェックする。その後、右下の「保存」を選んでメニューを閉じる。
1.2 資料
他に参考になる教材

情報処理学会 IPSJMOOC 第3章 https://sites.google.com/a.ipsj.or.jp/mooc/list
基本的なプログラミング
アルゴリズム
モデル化とシミュレーション
東京大学理学部情報科学科 Python入門 https://utokyo-ipp.github.io/index.html
京都大学 プログラミング演習 Python 2019 https://repository.kulib.kyoto-u.ac.jp/dspace/handle/2433/245698
Python入門（明治大学 水谷正大先生） https://www.isc.meiji.ac.jp/~mizutani/python/index.html
Chainer （Preferred Networks） 第2章の「Python 入門」 https://tutorials.chainer.org/ja/tutorial.html
Python入門（javadrive） https://www.javadrive.jp/python/
Python 公式チュートリアル https://docs.python.org/ja/3/tutorial/index.html
2 文字列を入力させて表示
キーボードから入力を求めて、その言葉を使って表示を行なうだけのプログラムである。

[ ]
12
yourname = input('Your name? ')
print('Oh! Your name is ', yourname)
Your name? a
Oh! Your name is  a
上のプログラムの解説

1行目：変数 yourname に、キーボードから入力された文字列を代入している。（数学では「変数」は、英文字1文字で、数や数値が入るが、プログラムの変数は、英文字で始まり英文字や数字が続く語であればよく、また、その値に文字列を想定することができる。
2行目：一定の書式を利用して、文字列を画面に表示する。
[ ]
  1
  2
yourname = input('君の名は？')
print('君の名は' + yourname +'なのか')
君の名は？ あおば
君の名前はあおばというのですね 
print 命令の中で、複数の文字列を並べるとき
カンマで区切ると、 空白がつく（最初のプログラム）
プラスでつなげると、文字列の結合をしたあとの「一つの文字列」になるので、空白がつかない。（2番めのプログラム）
3 繰返しとブロックの概念
3.1 ブロック
2行めの左側の空白（インデントという）を必ず入れること。同じ幅のインデントが続く行は、ブロックと見なされる。

[ ]
  1
  2
for i in range(10):
  print('i=' , i)
i= 0
i= 1
i= 2
i= 3
i= 4
i= 5
i= 6
i= 7
i= 8
i= 9
上のプログラムの解説

1行目：for のあとに変数名を書くと、その変数にさまざまな値を代入して、直後のブロック全体を実行する。 range(10) は、 0 から 9 までの10個の数を表している。
2行目：左側の字下げは、そこがブロックであることを示す。
[ ]
  1
  2
for i in range(6,11):
  print('i=', i)
i= 6
i= 7
i= 8
i= 9
i= 10
上のプログラムの解説

1行目：range(1,11)は、1 から 10 までの10個の数を表している。
[ ]
  1
  2
for i in range(10, 0, -5):
  print('i=', i)
i= 10
i= 5
1行目： range(10, 0, -1) は、10から1までの10個の数（ただし、1ずつ減少）を表している。
3.2 入力した言葉を繰り返して表示
次は、よい例

[ ]
  1
  2
  3
theword = input('favorite word?')
for i in range (10, 0, -5):
  print('Favorite word is ', theword, '.')
favorite word?COOL
Favorite word is  COOL .
Favorite word is  COOL .
次はよくない例

[ ]
  1
  2
  3
theword = input('favorite word?')
for i in range (5):
  print('Favorite word is', theword, '.')
favorite word?123
Favorite word is 123 .
Favorite word is 123 .
Favorite word is 123 .
Favorite word is 123 .
Favorite word is 123 .
for は繰り返しの部分を探しているが、見つからないためエラーになる。

3.3 繰返しながら途中を表示
[ ]
  1
  2
  3
  4
s = 0
for i in range(1, 11):
  s = s + i
  print('s=' , s)
s= 1
s= 3
s= 6
s= 10
s= 15
s= 21
s= 28
s= 36
s= 45
s= 55
上のプログラムの解説

3行目と4行目は、左側のインデントが同じ（左側の空白の幅が同じ）なので、カタマリとして考える。2行目の for で繰返し実行される命令が、3行目と4行目であり、ともに  100−2+1=99  回実行される。
[ ]
  1
  2
  3
  4
s = 0
for i in range(2, 101):
  s = s + i
print('s=', s)
s= 5049
上のプログラムの解説

3行目と4行目は、左側のインデントが異なる（左側の空白の幅が異なる）なので、別のカタマリとして考える。2行目の for で繰返し実行される命令が、3行目のみである。すなわち、3行目は99回実行されるが、4行目は1回しか実行されない。
3.4 数を入力して、その回数計算
[ ]
  1
  2
  3
  4
  5
s = 0
n = int(input('n? '))
for i in range(n+1):
  s = s + i
  print('s=', s)
n? 5
s= 0
s= 1
s= 3
s= 6
s= 10
s= 15
上のプログラムの解説

2行目：input は文字列を入力結果としている。これを数に変換する必要がある。関数 int は、入力された数字列を整数に変換する。
4行目：s + i の値を（新しい） s に代入する。
[ ]
  1
  2
  3
  4
  5
s = 0
n = int(input('n? '))
for i in range(n+1):
  s += i
  print('s=', s)
4行目は、「sの値を i 増加させる」という命令である。「 s = s + i 」と計算結果は同じ。
3.5 入力に応じて動作を変える
[ ]
  1
  2
  3
  4
  5
  6
  7
a = float(input('a? '))
b = float(input('b? '))
if b == 0 :
  print('Cannot divide by 0')
else:
  r = float(a) / float(b)
  print( float(a), '/', float(b), '=', float(r))
a? 123456
b? 1.2345678912346679889611000000000000000111
123456.0 / 1.234567891234668 = 99999.36080998671
上のプログラムの解説

1行目、2行目：関数 float は、入力された数字列を浮動小数に変換する。整数でない値を用いるときは、この float を利用する。
3行目： if は、条件が成立したときに直後のブロックを実行する。
3行目： b == 0 は、「 b が 0 に等しいかどうか」を判断する比較演算子である。ここを、 b = 0 と書いては いけない。
5行目： else は、 if の条件が成立しなかったときに直後のブロックを実行する。
4 繰り返し
繰り返しは、プログラムの動作の、基本構造の一つである。コンピュータは、繰り返しを素早く行うことで、様々な計算を行っている。

[ ]
  1
  2
  3
  4
  5
  6
  7
out = ''
out += 'a'
out += 'a'
out += 'a'
out += 'a'
out += 'a'
print(out)
aaaaa
このプログラムは、文字列を最初は空列（長さゼロ）にしておいて、それに、文字 a を追加するという作業を5回行って、最後に out を表示する。これを、繰り返しを使って記述すると、次のようになる。

[ ]
  1
  2
  3
  4
out=''
for i in range(5) :
  out += 'a'
print(out)
aaaaa
この作業を5回繰り返すと、正方形状に文字を並べることができる。

[ ]
  1
  2
  3
  4
  5
for j in range(5) :
  out=''
  for i in range(5) :
    out += 'a'
  print(out)
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
実習
(1) 次のプログラムはどのように動作するか。よく考えた上で、実行してみて、そのとおりになったかどうかを確認せよ。

[ ]
  1
  2
  3
  4
  5
for j in range(10) :
  out=''
  for i in range( j ) :
    out += 'a'
  print(out)

(2) 次のプログラムはどのように動作するか。よく考えた上で、実行してみて、そのとおりになったかどうかを確認せよ。

[ ]
  1
  2
  3
  4
  5
for j in range(10) :
  out=''
  for i in range( j*j ) :
    out += 'a'
  print(out)

a
aaaa
aaaaaaaaa
aaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
新しいセクション
(3) 次のプログラムを実行すると何が表示されるか。実行せずに考えて、その後、実行して確認せよ。

[ ]
  1
  2
  3
  4
  5
  6
for i in range(1,10):
  out =''
  for j in range(1,10):
    v = i*j
    out += str(v)+' '
  print(out)
1 2 3 4 5 6 7 8 9 
2 4 6 8 10 12 14 16 18 
3 6 9 12 15 18 21 24 27 
4 8 12 16 20 24 28 32 36 
5 10 15 20 25 30 35 40 45 
6 12 18 24 30 36 42 48 54 
7 14 21 28 35 42 49 56 63 
8 16 24 32 40 48 56 64 72 
9 18 27 36 45 54 63 72 81 
(4) 次のプログラムは、先のプログラムの改良型である。どのように改良されたか。実行せずに考えて、その後、実行して確認せよ。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
for i in range(1,21):
  out = ''
  for j in range(1,21):
    v = i*j
    if v < 10:
      out += '#'
    if v < 100:
      out += '#'
    out += str(v)+' '
  print(out)
##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 ##9 #10 #11 #12 #13 #14 #15 #16 #17 #18 #19 #20 
##2 ##4 ##6 ##8 #10 #12 #14 #16 #18 #20 #22 #24 #26 #28 #30 #32 #34 #36 #38 #40 
##3 ##6 ##9 #12 #15 #18 #21 #24 #27 #30 #33 #36 #39 #42 #45 #48 #51 #54 #57 #60 
##4 ##8 #12 #16 #20 #24 #28 #32 #36 #40 #44 #48 #52 #56 #60 #64 #68 #72 #76 #80 
##5 #10 #15 #20 #25 #30 #35 #40 #45 #50 #55 #60 #65 #70 #75 #80 #85 #90 #95 100 
##6 #12 #18 #24 #30 #36 #42 #48 #54 #60 #66 #72 #78 #84 #90 #96 102 108 114 120 
##7 #14 #21 #28 #35 #42 #49 #56 #63 #70 #77 #84 #91 #98 105 112 119 126 133 140 
##8 #16 #24 #32 #40 #48 #56 #64 #72 #80 #88 #96 104 112 120 128 136 144 152 160 
##9 #18 #27 #36 #45 #54 #63 #72 #81 #90 #99 108 117 126 135 144 153 162 171 180 
#10 #20 #30 #40 #50 #60 #70 #80 #90 100 110 120 130 140 150 160 170 180 190 200 
#11 #22 #33 #44 #55 #66 #77 #88 #99 110 121 132 143 154 165 176 187 198 209 220 
#12 #24 #36 #48 #60 #72 #84 #96 108 120 132 144 156 168 180 192 204 216 228 240 
#13 #26 #39 #52 #65 #78 #91 104 117 130 143 156 169 182 195 208 221 234 247 260 
#14 #28 #42 #56 #70 #84 #98 112 126 140 154 168 182 196 210 224 238 252 266 280 
#15 #30 #45 #60 #75 #90 105 120 135 150 165 180 195 210 225 240 255 270 285 300 
#16 #32 #48 #64 #80 #96 112 128 144 160 176 192 208 224 240 256 272 288 304 320 
#17 #34 #51 #68 #85 102 119 136 153 170 187 204 221 238 255 272 289 306 323 340 
#18 #36 #54 #72 #90 108 126 144 162 180 198 216 234 252 270 288 306 324 342 360 
#19 #38 #57 #76 #95 114 133 152 171 190 209 228 247 266 285 304 323 342 361 380 
#20 #40 #60 #80 100 120 140 160 180 200 220 240 260 280 300 320 340 360 380 400 
5 素数判定プログラム
ある自然数  p  が素数であるとは、 p を割り切る自然数は  1 と p のみのときである。そこで、 p を入力させ、 2,3,...,  と  p–√ までのそれぞれの数で割算を行ない、余りが0になるかどうかを調べれば、 p が素数かどうか、判定できる。

5.1 単純な判定方法の利用
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
import math

flag = 1
p = float(input('p? '))
limit = math.sqrt(p)
for i in range(2, int(limit)+1 ):
    r = p % i
    if r == 0 :
       flag = 0
print('flag=', flag)
p? 35464612397
flag= 1
上のプログラムの解説

1行目：数学計算ライブラリを呼び出す。
2行目：空行。プログラムを見やすくするために、このような行を入れてもよい。（いれなくてもよい。）
3行目：変数 flag は、プログラム終了時には、素数かどうかの判断結果となる。最初は 1 を入れておく。
4行目：math.sqrt(p) は  p の平方根,  p–√  で繰返し条件を定めた。
7行目：演算子 % は、余りの計算を行なう。
9行目：インデントが他と違う。ここは、8行目の条件が成立したときに限って実行される。
5.2 判定方法を変える
この計算の繰返し条件を、平方根を利用しないで  i2≤p  とすると、以下の通りになる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
i = 2
flag = 1
p = int(input('p?'))
while i*i <= p :
    r = p % i
    if  r == 0 :
       flag = 0
    i += 1
print('flag=', flag)
p?35464612397
flag= 1
上のプログラムの解説

4行目：while は、続く条件が成り立つ間、直後のブロックを繰返し実行し続ける。
問題
上記2つの判定方法の違いについて考察せよ。

6 ユークリッドの互除法
ユークリッドの互除法とは、世界で最古のアルゴリズムとされている方法で、ユークリッド原論（紀元前300年頃）に書かれている。基本的な考え方は、以下の通りである。

x>y  とする。また、  d  が、  x  と  y  の公約数であるとする。
横の長さが  x  、縦の長さが  y  の長方形は、一辺の長さが  d  の正方形で埋め尽くされる。
元の長方形から、一辺の長さが  y  の正方形を切り取ると、横の長さが  x−y  、縦の長さが  y  の長方形となるが、これも、一辺の長さが  d  の正方形で埋め尽くされる。
一辺の長さが  y  の正方形を切り取れなくなったら、縦横の考え方を変えて、同じことをしていく。
最後に正方形だけが残る。それも、一辺の長さが  d  の正方形で埋め尽くされる正方形となる。この辺の長さは、  x  と  y  の公約数のうち、最大のものである。
すなわち、与えられた2数に対し、大きい方から小さい方を引くという作業をずっと続けていく。途中で同じ値になれば、それが最大公約数である。ところで、「小さくなるまで何回も引き算をする」というのは、 「自然数の割算を行なって、余りを求める」ということと同じである。

キーボードから入力を求めることにして、Pythonで記述すると、次のプログラムとなる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
x = int(input("x?"))
y = int(input("y?"))
while x != y and x>0 and y>0 :
    if x > y :
        x = x % y
        d = y
    else :
        y = y % x
        d = x
print('answer=', d)
上のプログラムの解説

3行目： x≠y  のときに動作する。なお、うっかり、負の数を入力されたときに、暴走しないように、x, y が共に正である場合のみ動作するようにした。なお、条件を「かつ」で結ぶときは、 and を中置する。
問題　最初から、 x と y に同じ値を入れたときに、正しく動作させるには、このプログラムをどのように改造すればよいか。

7 リスト
リストとは、数列と同じように、いくつもの数を並べた「変数の列」（数列）のことである。一つの名前と、添字（index）を指定することで、その内容を呼び出せる。

a[0], a[1], a[2],....

この例では、リスト名は a である。Pythonを含む多くのプログラミング言語では、リストの添字は  0  から始まる（ zero-origin )が、一部のプログラミング言語では、リストの添字を  1  から始める( one-origin )。

リストは、数学の数列と異なり、長さは有限である。リストの要素に値を代入するために、特別な既報はない。以下のようにすれば、代入できる。

a[1] = 30

7.1.1 リストの長さ
len(hoge)

リスト hoge の長さ（要素の個数）を表す。len(hoge)の値が30なら、hoge[0]からhoge[29]まで要素がある。

7.1.2 リストに要素を追加する
hoge.append(x)

リスト hoge に、x が追加される。

7.1.3 リストの要素の和を求める
sum(hoge)

リストの要素のうち、数値のものをすべて加えた値になる。

7.1.4 リストをつなげて新しいリストを作る
リストを + でつなげると、リスト同士をつないだ新しいリストを表す。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
hoge = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30] 
print(hoge)
print(len(hoge))

hoge.append(31)

print(hoge)
print(len(hoge))

print(sum(hoge))

heijitsu = ["getsu", "ka", "sui", "moku", "kin"]
syumatsu = ["do", "nichi"]
youbi = heijitsu + syumatsu
print(youbi)
リストからグラフ
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
import matplotlib.pyplot as plt # グラフ描画ライブラリ

y=[0,1,4,9]

plt.plot(y) # 位置の配列をプロット
plt.title("parabollic motion") # グラフのタイトル
plt.xlabel("distance") #x 軸ラベル
plt.ylabel("height") #y 軸ラベル
plt.show()
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
import matplotlib.pyplot as plt # グラフ描画ライブラリ

x=[0,1,2,3]
y=[0,1,4,9]

plt.plot(x,y) # 位置の配列をプロット
plt.title("parabollic motion") # グラフのタイトル
plt.xlabel("distance") #x 軸ラベル
plt.ylabel("height") #y 軸ラベル
plt.show()
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
import matplotlib.pyplot as plt # グラフ描画ライブラリ

x=[0,1,2,3]
y=[0,1,4,9]

plt.scatter(x,y) # 位置の配列をプロット
plt.title("points") # グラフのタイトル
plt.xlabel("distance") #x 軸ラベル
plt.ylabel("height") #y 軸ラベル
plt.show()
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
!pip3 install ColabTurtle
from ColabTurtle.Turtle import *

#4角形
initializeTurtle(initial_speed=5)
color('orange')
bgcolor('white')
width(3)
for i in range(5):
    forward(200)
    left(144)
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
from PIL import Image, ImageDraw
im = Image.new('RGB', (600, 250), (128, 128, 128))
draw = ImageDraw.Draw(im)
for u in range(0, 5):
  draw.ellipse((75+20*u,75+20*u,80+22*u,80+22*u),fill=(255,128,0))
draw.arc((25, 50, 175, 200), start=30, end=270, fill=(255, 255, 0))
draw.chord((225, 50, 375, 200), start=30, end=270, fill=(0, 255, 0), outline=(0, 0, 0))
draw.pieslice((425, 50, 575, 200), start=30, end=270, fill=(255, 255, 255), outline=(0, 0, 0))
im
8 エラトステネスのふるい
たくさんの素数を探し出していく方法の一つに、「エラトステネスのふるい」と呼ばれる方法がある。ここでは、1 から  m  までの整数のうち、素数となるものをすべて求めてみよう。このプログラムを実行すると、

a[i] が1なら i は素数。
a[i] が0なら i は合成数。
という状態になることが目的であるとする。

最初は、すべての要素に 1 を代入して初期化しておく。
最初の  i=2  に対して、 2 以外の 2 の倍数  j(j=4,6,8,10,⋯)  は素数でないので、リストの j 番目  (j=4,6,8,10,⋯)  の要素 a[j] の値を  0  にする。
同様に、 3 以外の 3 の倍数  j(j=6,9,12,⋯)  も行なう。
i=4  では、  a[i]==0  であるから、これは飛ばす。
5 以外の 5 の倍数  j(j=10,15,20,⋯)  というようにして、つぎつぎと倍数を素数でないと判断していく。
これを続けていけばよい。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
import math

m = 1000
a = [1] * int(m+1)
limit = int(math.sqrt(m))
sosu = []

for i in range(2, limit+1):
  if a[i] == 1 :
    j = i + i  
    while j <= m :
            a[j] = 0
            j += i

for i in range(2, m+1):
  if a[i] == 1 :
    sosu.append( i )

print(sosu)
上のプログラムの解説

4行目：リストaに、最初は(4行目から6行目で)すべて 1 を代入しておく。（Python での初期化の、独特の書き方）
5行目：変数  i  は、  m−−√  の直前まで調べればよい。そこで、その境界を設定する。
6行目では、見つかった素数を格納するリストを用意しておく。
8行目では、  i<m−−√+1  という条件を使って、  i  の範囲を指定している。
9行目で、  i が素数であると判定したら、
9行目で、  j=i+i=2i  を設定し、
10行目から12行目で、  j=2i,3i,...  と、可能なところまで a[j] の値を0にする。
15行目から17行目で、改めて、a[ 2 ]からa[ m ]までのうち、a[ i ] が1 のものは、 i が素数であるから、リスト sosu に追加する。このとき append を利用している。
9 関数定義
一定の手順をまとめて計算する作業のことを、プログラミングの世界では、関数(function)という。関数の定義には、さまざまなやりかたがあるが、ここでは、ごく簡単な例を紹介する。 いま、ある色 の RGB成分が、  r,g,b  であるとする。このとき、次の式で計算される  v  の値は、その色の明度と呼ばれる値である。

v= r×299+g×587+b×114 1000 

Webのさまざまな規格を定めている W3Cという団体では、視覚障害者のことを考えたユニバーサルデザインを実現するため、画面の色の背景と文字の明度差が 125 以上になることを求めている。 以下のPython の関数 brightness  (r,g,b)  は、3つの引数（ひきすう）  r,g,b  を受け取って、明度を返すようになっている。始めに、文字色のRGBとして  r1,g1,b1  を入力させ、次に、背景色のRGBとして  r2,g2,b2  を入力させ、W3C勧告にしたがっているかどうかを判定することができる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
def brightness(r, g, b):
  v = ( r*299 + g*587 + b*114 )/1000
  return v

rfor = int(input('forground red? '))
gfor = int(input('forground green? '))
bfor = int(input('forground blue? '))
forgroundbrightness = brightness(rfor, gfor, bfor)

rback = int(input('background red? '))
gback = int(input('background green? '))
bback = int(input('background blue? '))
backgroundbrightness = brightness(rback, gback, bback)

diff = abs( forgroundbrightness - backgroundbrightness )
print('difference=', diff)
if diff < 125:
  print('Bad')
else:
  print('Good')
上のプログラムの解説

1行目：関数の定義である。 def に続けて、関数名と引数を並べて書く。
3行目： return を利用して、返す値を決める。
15行目：自分で定義した関数を呼び出して計算する。
10 乱数の利用
10.1 確率を利用したゲーム
次のプログラムは、人間が出した「手」と、コンピュータが出した「手」を比較して、じゃんけんの勝ち負けとして勝敗を決めるプログラムである。

ramdom.random() は、0 以上 1 未満の数をとる。どのような値になるかは、簡単には類推できず、また、その値を参照するたびに、異なる値となる。
[ ]
  1
  2
  3
  4
  5
  6
  7
import random

hands = ['Gu', 'Tyoki', 'Pa']
out = 'My hando is '
x = int(3*random.random())
out += hands[x]
print(out)
1行目：乱数計算モジュールを利用する宣言をする。
4行目：出力文の最初を代入しておく。
5行目： 0以上1未満 で生成された乱数を3倍し、整数部分を取り出すことで、 0, 1, 2 を等確率で発生させる。
6行目：手を出力文に追加する。
7行目：出力文を表示する。
10.2 近似値の計算
まず、以下の二つの領域を考える。

Q={(x,y) | 0≤x2+y2≤1} 
R={(x,y) | 0≤x<1かつ0≤y<1} 
R  内に、ランダムに点を打つと、確率  π4  で、その点は  Q  の中に入る。

今、乱数を使って  R  内に  n  個の点を打ってみる。このとき、  Q  に入っている点が  s  個であったとする。

そうすると、点が増えるにしたがって、比率  h=sn  の値は  π4  に近付くはずである。すなわち、  4h=4sn  は  π  に近付くはずである。

このようにして、解析的に求めたい値を、実験的に求める数値計算の方法を、「モンテカルロ法」という。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
import numpy.random as rd

incount = 0
n = int(input('How many points do you use? '))
for i in range(n):
  x = rd.random()
  y = rd.random()
  if  x*x + y*y < 1 :
    incount += 1
p = 4*incount / n
print('4*', incount, '/', n, '=', p)
10.3 図示
【参考】 ここでは、Pythonのグラフ機能を利用して、この方法での点の描画を図示してみる。いままでに利用されていない命令を利用しているので、適宜、資料などをみて勉強してほしい。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
import numpy.random as rd # 乱数を発生させる関数の呼び出し
import matplotlib.pyplot as plt # グラフプロットの呼び出し
n = int(input('How many points do you use? ')) # ランダムに打つ点の総数
incount = 0 # 円に入った点の数
plt.figure(figsize=(5,5))
for i in range(n):
  x = rd.random() #0-1 の範囲の値
  y = rd.random() #0-1 の範囲の値
  if x*x + y*y < 1.0: # 単位円の中に入ったら
    incount += 1 # 入ったカウンターに１を加える
    plt.scatter(x, y, c="red") # 赤色でプロット
  else:
    plt.scatter(x, y, c="blue") # 青色でプロット
p = 4*incount / n
print(" 円周率 :", p ) # 求まった円周率の近似値
plt.title("Monte Carlo method") # グラフのタイトル
plt.show()
問題
円周率を求めるのに、モンテカルロ法は得策ではない。なぜか。

11 探索の手順とプログラム
いま、 C0,C1,⋯,Cn−1  の、  n  枚のカードがあり、手順が始まるまえに、すでに、その値は設定されているとする。探したい値を、  q  とする。すなわち、 Ck=q  となる  k  の値を求めることが必要となる。

さて、コンピュータはどのようにして情報を探しているのだろうか。ある特定の条件を満たすものがあるかどうかを調べる作業のことを、「探索」（サーチ）という。このとき、探索したいデータのことをクエリという。データを探索するアルゴリズムは何通りもあり、それぞれに長所・短所がある。ここでは、探索アルゴリズムを2つ説明する。

以下のアルゴリズムでは、長さ1023のリスト b の中に、クエリと一致する要素を探すという状況で考え、query には、クエリの値が代入されているとする。

b[0]285b[1]496b[2]5b[3]946b[4]20................b[1021]20b[1022]163 

11.1 線形探索
コンピュータの内部では情報はすべてメモリに記憶されていて、メモリは一列に並べられている。クエリがデータベースの中にあるのかを、メモリの端から端まで調べる方法を全探索という。小説の中にある単語が含まれているか調べるなどの場合は、この方法を利用する。

1枚目から順にカードを見ていって、探したいカードが見つかったら、そこで終了するという手順である。

表示だけでなく、見つかったか見つからなかったかに応じて、ある変数の値を設定して、他で利用することも考えるためには、例えば、変数 flag の値を、つぎのように計算する手順を作ることにする。

flag が 0 →まだ見つかってない
flag が 1 →見つかった
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
b = [85,96,6,22,10,94,71,38,43,63]
flag = 0
nagasa = len(b)
query = int(input('query? '))

for i in range(nagasa):
  print('b[', i, ']=', b[i], 'is', query, '?')
  if query == b[i] :
    flag = 1

print('flag=', flag)
break を利用することで、見つかったときは、探索を中断させることができる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
b = [85,96,6,22,10,94,71,38,43,63]
flag = 0
nagasa = len(b)
query = int(input('query? '))

for i in range(nagasa):
  print('b[', i, ']=', b[i], 'is', query, '?')
  if query == b[i] :
    flag = 1
    break

print('flag=', flag)
さらに、Python の for でリストを使う方法もある。（Pythonっぽい）

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
b = [85,96,6,22,10,94,71,38,43,63]
flag = 0
query = int(input('query? '))

for i in b:
  print(i, '==', query, '?')
  if i == query:
    flag = 1
    break

print('flag=', flag)
行10 の break を実行すると、そのときに行われている一番小さい for, while の繰り返しを中断させる。
線形探索の計算量
もし、相異なる  n  枚のカードがあって、そのなかに確実に目的のカードがあるとするとき、カードを見る回数の平均を求めてみよう。

探したいカードが1枚目の確率は  1 n   である。探したいカードが2枚目の確率も  1 n   であるが、このとき、カードを2回見ている。

このように考えると、カードを1回だけ見る確率も、カードを2回だけ見る確率も、そして、カードを  n  回だけ見る確率も、すべて  1 n   である。よって、カードを見る回数の平均（期待値）は、以下の式で求めることができる。

1 n +2 n +⋯+n n =  n(n+1)2  n=n+12 

11.2 二分探索
C0,C1,⋯,Cn−1  の、  n  枚のカードがあり、すべて左から右に整列済みであると仮定する。

このとき、値  q  が、このカードの中にあるかどうかを調べるために、まず、カードをちょうどまんなかで半分に分け、左側の右端（小さい値を持つ側のもっとも大きい値）と  q  を比較する。

そこに探している値があれば、そこで終了する。もし、  q  の方が大きいなら、この右側をさらに半分にする。もし、  q  の方が小さいなら、左側の方をさらに半分にする。このようなことを何度も、最後に1枚なるまで続ける。 このようにして探索範囲を半分ずつにしていく方法を二分探索という。

二分探索のプログラム
もし、リスト b[0]  ∼  b[1022] が整列されているならば、リストの前半の最大値 b[511] とqueryの大小関係を比較することで、次のことがわかる。

query  ==  b[511] ならば、見つかった。
上の条件が成り立たなくて、 query  <  b[511] ならば b[0]  ∼  b[510] を調べればよい
どっちもダメなときは、query  >  b[511] なので b[512]  ∼  b[1022] を調べればよい
見つからなかった場合、511個のどこにあるかを探すことになる。

例えば、ここで b[0] ∼ b[510] 側を調べることになったら、今度は query と b[255] を比較することで、

query  ==  b[255] ならば、見つかった。
上の条件が成り立たなくて、 query  <  b[255] ならば b[0]  ∼  b[254] を調べればよい
どっちもダメなときは、query  >  b[255] なので b[256]  ∼  b[510] を調べればよい
となる。見つからなかった場合、255個のどこにあるかを探すことになる。

二分探索を Pythonで書く
次のプログラムの通りとなる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
b = [1,6,10,12,21,22,25,29,38,43,44,63,71,85,94,96]
flag = 0
nagasa = len(b)
query = int(input('query? '))
start = int(0)
end = int(nagasa-1)
while start <= end:
  center = int((start+end)/2)
  if query == b[center] :
    flag = 1
    break
  elif query < b[center] :
    end = center - 1
  else :
    start = center + 1
print('flag=', flag)
二分探索の手間を評価する
例えば、  n=1023  枚のカードで、この方法を行なうとすると、最初の時点で真中に見つからない場合、対象となるカードは  511  枚に絞られる。次の時点で真中に見つからない場合、対象となるカードは  255  枚に絞られる。このようにしていくと、多くても10回の繰り返しでカードは必ず1枚になる。（途中で見つかるかも知れない。）

言い替えるなら、二分探索では、  p  回の繰り返しをすれば、 2p−1  枚のカードからの探索ができることから、カードの枚数を  n  とすると、繰返しの回数は、おおむね  log2n  回程度となる。

二分探索は、最初の整列には非常に手間がかかるが、いったん整列した後では、探索が高速にできるので、同じデータから何度も探索をしたいときに有用である。

12 整列の手順とプログラム
データを取り扱うときに、そのデータを小さい順や大きい順などに並べておくことがおおい。例えば、二分探索を行なうには、要素がすべて整列されていることが必要となる。

このような並べ替えのことを整列（sort）と言う。データを整列するアルゴリズムは何通りもあり、それぞれに長所・短所がある。ここでは、対象を、以下の数が書かれたカードであるとする。

64371825 

準備：値を交換する手順
これから述べるアルゴリズムは、一列に並べられた10枚のカードのなかから、2枚のカードの置き場所を交換するように、リスト b の2つの要素の値を交換して処理を進める。これには、片方のリスト要素の値を一時的に覚えておく専用の変数(例では tmp )を用意しておくという工夫が必要となる。

b[2] が531
b[5] が163
↓

tmp = b[2]
b[2] = b[5]
b[5] = tmp
↓

b[2] が163
b[5] が531
多くのプログラミング言語では、このようにして、一時的な変数を用意しておく必要がある。 ただし、Pythonは、ここを、

b[2], b[5] = b[5], b[2]
のように簡単に書く方法がある。

12.1 選択ソート
まず、選択ソートという方法について述べる。

第1手順: まず、一番右端に、このなかで最大の数が来るように、カード（数値）の交換をする。
第2段階: 残りの数の中で最大の数を右から2番目になるようにする。
第3段階: 残りの数の中で最大の数を右から3番目になるようにする。
第4段階: 残りの数の中で最大の数を右から4番目になるようにする。
選択ソート法のアルゴリズムの記述
いま、 C0,C1,⋯,Cn−1  の、  n  枚のカードがあり、この手順が始まるまえに、すでに、その値は設定されているとする。そのとき、選択ソートをPythonで記述すると、次のプログラムとなる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
def selectionsort(arg):
  nagasa=len(arg)
  for e in range(nagasa-1, 0, -1):
    for s in range(0, e):
      if arg[s] > arg[e]:
        arg[s], arg[e] = arg[e], arg[s]

# main part
seq = [56, 85, 96, 6, 22, 10, 94, 71, 38, 43, 63, 24, 3]

print("Before")
print(seq)

selectionsort(seq)

print("After")
print(seq)
上のプログラムの解説

5行目： arg[e] よりも大きな要素 arg[s] を見つけたら、
6行目：その値を交換する。
選択ソートの計算の手間
ここでは、上記のアルゴリズムにある、 Cs  と  Ce  を比較する回数を考える。これは、 e  回繰り返される。そして、この手順自体は、 e  の値を変えながら、繰り返される。

問題
選択ソートによく似た整列法として、以下のものも知られている。調べて、Pythonでプログラムを書いて見よ。

バブルソート
挿入ソート
【注意】Pythonの内部関数を利用した整列
Pythonには、プログラマが整列のアルゴリズムを知らなくても、リストの中身を整列してしまう方法があるが、授業では扱わない。これは、そもそも、整列の手順を知ることによって、アルゴリズムによる計算能力を身に付けるために、この授業が行なわれているからである。（したがって、実用世界では、Pythonの内部関数を利用した整列を使ってもよい。）

13 ハノイの塔
「ハノイの塔」と呼ばれる有名な問題がある。ルールは以下の通り。

3つの棒が地面に立てられている。  A0,A1,A2  と呼ぶことにする。
棒  A0  には、中央に穴があいている直径が異なる  n  枚の円盤が、下に大きいもの、上に小さいものになるように積まれている。
あなたは、1回で1枚の円盤を別の棒に移してよい。
小さい円盤の上に大きい円盤を載せてはいけない。
円盤を重ねて移動してはいけない。
円盤は、棒に通した状態でしか置くことが出来ない。
すべての円盤を、  A0  以外の1つの棒に移すことができれば、終りである。
13.1 手順
円盤が2枚のとき

A0  から  A1  に円盤（小）を移す。
A0  から  A2  に円盤（大）を移す。
A1  から  A2  に円盤（小）を移す。
円盤が3枚のとき どうすればよいだろうか？以下の手順でできることがわかる。

A0  から  A1  に円盤2枚を移す。
A0  から  A2  に円盤（最大）を移す。
A1  から  A2  に円盤2枚を移す。
ここに、「  A0  から  A1  に円盤2枚を移し」という記述があるが、この作業はすでにできることがわかっているので、省略して書いてあるが、ていねいに書くと、次の通りになる。

A0  から  A1  に円盤2枚を移す。
A0  から  A2  に円盤（小）を移す。
A0  から  A1  に円盤（大）を移す。
A1  から  A2  に円盤（小）を移す。
A0  から  A2  に円盤（最大）を移す。
A1  から  A2  に円盤2枚を移す。
A1  から  A0  に円盤（小）を移す。
A1  から  A2  に円盤（大）を移す。
A0  から  A2  に円盤（小）を移す。
では、円盤が4枚のときはどうすればよいか。これは、次の手順でできる。

A0  から  A1  に3枚の円盤を移す。
A0  から  A2  に円盤（最大）を移す。
A1  から  A2  に3枚の円盤を移す。
3枚の円盤の移動がすでに可能であることがわかっているので、それを利用すればよいということになる。このようにすれば、円盤の枚数  n  がどんな値であったとしても、以下の手順で移動ができるということがわかる。

A0  から  A1  に  n−1  枚のを移す。
A0  から  A2  に円盤（最大の円盤）を移す。
A1  から  A2  に  n−1  枚の円盤を移す。
13.2 手順を部品にする
n  枚の円盤を、棒  Ax  から棒  Ay  に 移動させる（棒  Az  を作業用に利用する）手順を書いてみる。これを、Hanoi(n,x,y,z) と呼ぶことにする。例えば、Hanoi(5,0,1,2) は、5枚の円盤を、  A0  から  A1  に移動させる。そのときに、  A2  は作業用に使ってよい、という意味である。

この手順を、「3つの棒を A, B, C と名付け、3枚の円盤を利用する場合」に、これを Python で記述すると、次のプログラムとなる。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
def hanoi(n, x, y, z):
  if n == 1:
    print('disc', n, ':', x, '->', y, '.')
  else:
    hanoi(n-1, x, z, y)
    print('disc', n, ':', x, '->', y, '.')
    hanoi(n-1, z, y, x)

k=int(input('k? '))
hanoi(k, 'A', 'B', 'C')
13.3 再帰呼出し
前節の手順では、Hanoi(3,0,1,2) を求めるには、途中で、Hanoi(2,0,2,1) と、Hanoi(2,2,1,0) が必要になる。そして、Hanoi(2,0,2,1) を求めるには、途中で、Hanoi(1,0,1,2) と、Hanoi(1,1,2,0) が必要になる。

このように、Hanoiという手順のなかでHanoiを呼び出している。このように、ある手順の途中で自分自身を呼び出すことを再帰呼出しという。

問題
たらい回し関数とよばれる関数がある。有名なものとしては、アッカーマン関数、竹内関数である。Python でプログラムを作成してみよ。

アッカーマン関数 https://mathworld.wolfram.com/AckermannFunction.html
竹内関数 https://mathworld.wolfram.com/TAKFunction.html
14 クイックソート
14.1 クイックソートの手順
この方法では、対象となる領域からカードを一枚取り出して、そのカードの値よりも大きな値を右側に、そのカードの値よりも小さな値を左側に積む、という作業を何度も行なう。

第1手順: まず、一番右端のカードを取り出して、自分の前におく。これを pivot （閾値、要め）と呼ぶ。
第2手順: pivot よりも大きな値のカードを右側に、山積みにする。pivot よりも小さな値のカードを左側に、山積みにする。
このようにして、pivot （先頭のカードの値）を見て残りを二つの山にわけていく作業をしていけば、やがて、カードは1枚になり、整列が簡単にできる。クイックソートは再帰を使って書くことができる。

14.2 Python でクイックソート
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
def quicksort(target):
  nagasa=len(target)
  if nagasa <= 1:
    return target
  pivot = target[0]
  foo = [pivot]
  smaller = []
  larger = []
  for x in range(1, nagasa):
    if target[x] <= pivot:
      smaller.append(target[x])
    else:
      larger.append(target[x])
  smaller = quicksort(smaller)
  larger = quicksort(larger)
  return smaller + foo + larger 

# main part
 
seq = [56,85,96,6,22,10,94,33,71,38,43,63,1]

print("Before", seq)
seq = quicksort(seq)
print("After ", seq)
14.3 クイックソートの計算の手間
すでに述べた選択ソートの場合、 n  個の数を整列させるために、数同士の比較を  n(n−1)2  回行なう必要があった。クイックソートの場合、最初に並んでいる数の状況によって必要となる比較回数は異なるが、平均すると、 nlog2n  回程度で済むことがわかっている。これは例えば、約  n=1,000  の場合、選択ソートだと約  50万  回の比較だが、クイックソートなら、約  1万  回で済むということである。

データを整列させておけば、二分探索によって高速にデータを捜し出すことができることから、データの整列方法の研究成果は多い。現在は、データの特徴によって、さまざまな整列方法が使い分けられている。

問題
他の整列法として、以下のものも知られている。調べて、Pythonでプログラムを書いて見よ。

マージソート
ヒープソート
15 放物運動のシミュレーション（情報処理学会MOOC教材より転載）
物体を投げ上げたときの落下の軌跡を予想する
空気抵抗を考慮しなければ、横方向の等速運動と縦方向の等加速度運動で動きを予想できる
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
import math as math # 数値計算ライブラリ
import matplotlib.pyplot as plt # グラフ描画ライブラリ

dt = 0.01 # 微小時間 ( 時間間隔 )
v0 = 30 # 初速度
g = 9.8 # 重力加速度
x = [0] # 水平位置の初期値 0
y = [0] # 鉛直位置の初期値は 0
angle = 45.0 * math.pi / 180.0 # 投げ上げ角度
vx = [v0 * math.cos(angle)] # 水平方向の初速度
vy = [v0 * math.sin(angle)] # 鉛直方向の初速度
for i in range(1000):
  vx.append( vx[i] ) # 微小時間後の水平方向の速度
  vy.append( vy[i] - g * dt ) # 微小時間後の鉛直方向の速度
  x.append( x[i] + vx[i] * dt ) # 微小時間後の水平位置
  y.append( y[i] + ( vy[i] + vy[i+1] ) / 2.0 * dt ) # 微小時間後の鉛直位置
  if y[i] <  0 : # もし鉛直位置が 0 を下回ったら
    break # ループ中断

plt.plot(x,y) # 位置の配列をプロット
plt.title("parabollic motion") # グラフのタイトル
plt.xlabel("distance") #x 軸ラベル
plt.ylabel("height") #y 軸ラベル
plt.show()
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
import math as math # 数値計算ライブラリ
import matplotlib.pyplot as plt # グラフ描画ライブラリ

dt = 0.01 # 微小時間 ( 時間間隔 )
v0 = 30 # 初速度
g = 9.8 # 重力加速度
x = [0] # 水平位置の初期値 0
y = [0] # 鉛直位置の初期値は 0
h = 0.9 # 反発係数
angle = 45.0 * math.pi / 180.0 # 投げ上げ角度
vx = [v0 * math.cos(angle)] # 水平方向の初速度
vy = [v0 * math.sin(angle)] # 鉛直方向の初速度
for i in range(1000):
  vx.append( vx[i] ) # 微小時間後の水平方向の速度
  x.append( x[i] + vx[i] * dt ) # 微小時間後の水平位置
  next_vy =  vy[i] - g * dt # 微小時間後の鉛直方向の速度
  next_y = y[i] + ( vy[i] + next_vy ) / 2.0 * dt # 微小時間後の鉛直位置
  if next_y > 0 : # もし微小時間後の鉛直位置が 0 より大きいなら
    vy.append( next_vy )
    y.append( next_y ) # 微小時間後の鉛直位置
  else: # そうでないなら反発させる
    vy.append( -next_vy * h ) #反発係数 h
    y.append( -next_y ) # 反発したあとの位置

plt.plot(x,y) # 位置の配列をプロット
plt.title("parabollic motion") # グラフのタイトル
plt.xlabel("distance") #x 軸ラベル
plt.ylabel("height") #y 軸ラベル
plt.show()
16 統計処理
PythonにはNumPyと呼ばれる拡張モジュールが存在する。 まずはNumPyを導入してみよう。 import numpyはNumPyを使えるようにする。 as npという部分は、numpyを省略した形で使えるようにしている。

[ ]
  1
import numpy as np
関数を使うためのデータも用意しておく。5が2つあることに注意しよう。

[ ]
  1
a = np.asarray([1,2,3,4,5,5,6,7,8,9,10])
16.1 基本的な関数
いくつかの基本的な関数を見ていこう。実行しながら確認してみよう。

16.1.1 最大値と最小値
[ ]
  1
np.max(a)

10
[ ]
  1
np.min(a)

1
16.1.2 和
[ ]
  1
np.sum(a)
16.1.3 平均と中央値
[ ]
  1
np.mean(a)
[ ]
  1
np.median(a)
16.2 分散と標準偏差
dataには正規分布に従う乱数によって取得された1000個の点が格納されている。標準偏差は10になるように調整してある。 正規分布がよくわからない場合、標準偏差が10に近くなっていることを確認できていれば良いとする。

[ ]
  1
data = np.random.randn(1000,1)*10
[ ]
  1
np.var(data)

100.1178598318282
[ ]
  1
np.std(data)
16.3 相関係数
10人クラスのテストの点数とレポートの評価が次のようになったとする。 それぞれ左の数字がテストの点数、右の数字がレポートの評価となっている。

10 3
30 5
50 6
60 7
70 8
70 7
80 9
80 8
90 9
100 10
まずは図示してみよう。

[ ]
  1
  2
  3
  4
  5
testscore = [10,30,50,60,70,70,80,80,90,100]
reportscore = [3,5,6,7,8,7,9,8,9,10]

import matplotlib
matplotlib.pyplot.scatter(testscore,reportscore)
グラフからは正の相関があるだろうという予想がつく。 では相関係数を求めてみよう。

[ ]
  1
np.corrcoef(testscore,reportscore)
0.98377168という数字が相関係数になっている。グラフと見比べると正しそうだとわかる。

16.4 データの順位
例えば以下の50m走の順位を知りたい時には以下のように実行できる。4.5という数字は9がないのが見てわかるように、同着を表している。

[ ]
  1
  2
  3
  4
  5
fiftymetertime = [6.21,8.19,5.99,7.15,8.20,7.22,7.15,7.57,7.90,8.23,6.25,9.18]

from scipy.stats import rankdata

print(rankdata(np.array(fiftymetertime)))
特定のタイムが何位に相当するかも調べることができる。 例えば5.99が何位に相当するか知りたいならば、左から３番目なので以下のxの値に3を代入すると、何位か表示できる。xの値を変えれば、別のタイムの順位についても知ることができる。

[ ]
  1
  2
  3
  4
  5
x=3
a = rankdata(np.array(fiftymetertime))

print("タイムは" + str(fiftymetertime[x-1]))
print("順位は" + str(a[x-1]))
16.5 演習
与えられたデータの

最大値
最小値
総和
平均値
中央値
分散
標準偏差
相関係数
データの順位
について自分で分析してみよう。データは気象庁より取得した練馬区の過去1ヶ月の最高気温を用いる。

[ ]
  1
  2
htemp = [25.9, 29.7, 26.9, 23.4, 28.5, 17.1, 22.0, 23.3, 22.3, 27.1, 29.6, 26.9, 29.0, 27.5, 28.8, 21.6, 30.0, 20.1, 18.8, 15.4, 14.0, 19.3, 
         24.1, 26.8, 27.1, 25.0, 26.9, 25.8, 28.9, 28.3, 24.6]
結果を表示するときには

# print("最大値は:" , max(htemp))
などのように、その値が何を示しているのかわかるようにしましょう。 相関係数以外の項目に関して、以下のセルで実行してみよう。

[ ]
  1
print("最大値は:" , max(htemp))
最後に相関係数を試してみよう。 最高気温のデータに追加で日照時間のデータを追加する。

[ ]
  1
  2
stime = [11.9, 12.4, 7.3, 1.9, 7.3, 0.0, 12.8, 11.0, 2.3, 4.2, 8.9, 3.9, 9.8, 12.7, 6.5, 0.0, 12.7, 0.0, 0.0, 
         0.0, 0.0, 0.4, 2.7, 8.3, 7.1, 0.2, 3.7, 4.8, 12.6, 9.5, 0.0]
最高気温と日照時間の相関係数を求めてみよう。配列に格納されているデータはお互い対応しているものとする。

[ ]
  1

17 データ分析とグラフ
17.1棒グラフ
棒グラフを表示させる方法を以下に示す．これは果物の値段を表す棒グラフである．

[ ]
  1
  2
  3
  4
#まず，matplotlibというライブラリをインポートする．これはグラフの描画をするためのものである．実行すると、しばらくメッセージが表示されるだけで、なにか計算を行うわけではない。エラーなく終われば、この先に進む準備完了となる。
import matplotlib.pyplot as plt
!pip install japanize-matplotlib
import japanize_matplotlib
さっそく棒グラフを表示してみよう。

[ ]
  1
  2
  3
  4
  5
  6
fruit = ['apple', 'orange', 'grape']
price = [100, 40, 300]
plt.bar(fruit, price)
plt.xlabel("果物")
plt.ylabel("値段（円）")
plt.show()
＜解説＞

果物の名前が横軸，値段が縦軸にくるので，それぞれ配列に入れる．
plt.barで棒グラフが描け，かっこの中の第一引数に横軸の値，第二引数に縦軸の値を入れる．
plt.xlabel，plt.ylabelでx軸，y軸のラベル名を設定
plt.show()で表示
17.2. 折れ線グラフ
折れ線グラフを表示させる方法を以下に示す． これは月ごとの気温の変化を表すグラフである．

[ ]
  1
  2
  3
  4
  5
  6
month = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
temperature = [5, 6, 10, 15, 21, 23, 26, 26, 23, 17, 13, 8]
plt.plot(month, temperature, marker="x")
plt.xlabel("月")
plt.ylabel("気温（度）")
plt.show()
＜解説＞

横軸の月と縦軸の気温を配列に入れる
plt.plotで折れ線グラフがかけ，第一引数に横軸の値，第二引数に縦軸の値，第三引数にマークの形を入れる．
離散空間上の線形計画問題
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
import matplotlib.pyplot as plt
suzuran=90
kasumi=140
p_saidai=0
a_saidai=0
b_saidai=0
hana_a=0
a=[]
p=[]

while ( (suzuran>=0) and (kasumi>=0) ) :
  hana_b=min(int(suzuran/2), int(kasumi/3))
  price=300*hana_a+190*hana_b
  print('A=', hana_a, ', B=', hana_b, ', P=', price) 
  a.append(hana_a)
  p.append(price)
  if ( price > p_saidai ) :
    p_saidai=price
    a_saidai=hana_a
    b_saidai=hana_b
  hana_a+=1
  suzuran-=3
  kasumi-=5

plt.plot(a, p)
plt.xlabel("A")
plt.ylabel("price")
print('Result: A=', a_saidai, ', B=', b_saidai, 'P=', p_saidai) 
17.3. 散布図
散布図を表示させる方法を以下に示す．これは気温とアイスクリームの売上の関係を表すものである．

[ ]
  1
  2
  3
  4
  5
  6
temperature = [21, 22, 24, 24, 27, 28, 29, 30, 32, 33, 33, 33, 35, 35, 37]
sales = [4.4, 4.5, 4.3, 5.2, 4.9, 5.2, 5.6, 5, 5.7, 5.2, 6, 6.2, 6, 6.1, 7.1]
plt.scatter(temperature, sales)
plt.xlabel("気温（度）")
plt.ylabel("売上（万円）")
plt.show()
＜解説＞

横軸の気温と縦軸の売上を配列に入れる
plt.scatterで散布図がかけ，第一引数に横軸，第二引数に縦軸の値を入れる．
18 WebAPI （情報処理学会MOOC教材より転載）
WebAPIとは，Web経由でアクセスできるサーバの機能を使って，情報などを取り出すプログラム間のやりとりを定めたインタフェースのことです。定まった手順にしたがって要求することにより，自前では持っていない機能を自分のプログラムの中で使うことができ，それを元に簡単なプログラムで，高機能なサービスを提供することができるようになります。

例）zip cloudが提供する郵便番号検索APIを使って指定した郵便番号から住所を表示するプログラム

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
import requests
import json

url = "http://zipcloud.ibsnet.co.jp/api/search" # 使用するWebAPI のURL
param = {"zipcode": "100-0013"} #WebAPI の引数

res = requests.get(url,params=param) #WebAPI の戻り値がres へ
response = json.loads(res.text)
address = response["results"][0]

print(address["address1"] + address["address2"] + address["address3"])
このプログラムは，郵便番号データ配信サービス「zip cloud」が提供するWebAPIを使って，指定した郵便番号の住所を取り出して，表示するプログラムです。

requestsモジュールはWebサーバとデータをやり取りするためのHTTP通信ライブラリです。
jsonモジュールはWebAPIでやり取りするJSON形式のデータを処理するためのものです。
変数urlにWebAPIのURL，paramに調べたい郵便番号をセットします。
requests.get()を用いて，指定したURLに郵便番号を引数としてアクセスし，返答を変数resに受け取ります。その結果をjson.loads()を使って解析します。
APIの規則に従い，住所に関するデータをaddressに代入すると，address["address1"]で都道府県名，address["address2"]で市区町村名，address["address3"]で町域名が参照できるようになります。
ディクショナリ
{"zipcode": "100-0013"}と書かれた形式のデータはディクショナリと呼ばれます。これを変数pramに代入すると，param["zipcode"]という形で，添字に文字列を指定したデータ参照ができます。最後に表示した変数addressもディクショナリで，"address1"などを添字としてデータを参照して表示しています。(どういうデータが入っているかは，print(address)を最後に追加してみると見ることができます。)

演習）上のプログラムを郵便番号を入力してもらって結果を表示するように変更しましょう。

[ ]
  1
  2
  3
  4
  5
import requests
import json

zip = input("郵便番号を入力してください: ")

19 データの活用 （情報処理学会MOOC教材より転載）
WebAPIを利用する以外に，外部に置かれたデータを読み込み活用することもできます。

例）気象庁のCSVデータを読み込んで最高気温をプロット

[ ]
  1
  2
  3
  4
  5
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('https://www.data.jma.go.jp/obd/stats/data/mdrr/tem_rct/alltable/mxtemsadext00_rct.csv',encoding='sjis')
plt.scatter(df['観測所番号'], df['今日の最高気温(℃)'])
このプログラムでは，気象庁が毎日更新してサイトに置いている各地の最高気温データを散布図としてプロットしています。データの処理およびデータの視覚化を行うためモジュールpandas，グラフを表示するためのモジュールmatplotlib.pyplotを使っています。importの中でasを使うことにより，左のモジュール名を書く代わりに，右の文字列で代替することができます。pandasのread_csvを使うことにより，指定したURLのCSVデータをリストdfに読み込みます。encoding='sjis'で，CSVファイルの漢字コードをSJISであると指定しています。これにより，読み込んだデータの項目名を使ってディクショナリでデータを参照できます。最後の行ではmatplotlib.pyplotのscatterを使い，x軸に読み込んだ項目の'観測所番号'，y軸に項目'今日の最高気温(℃)'とり，データをプロットしています。

例）気象庁のCSVデータを読み込んで最高気温をプロット（昨日までの観測史上1位の値で色を変える）

[ ]
  1
  2
  3
  4
  5
  6
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('https://www.data.jma.go.jp/obd/stats/data/mdrr/tem_rct/alltable/mxtemsadext00_rct.csv',encoding='sjis')
plt.scatter(df['観測所番号'], df['今日の最高気温(℃)'], s=50, c=df['昨日までの観測史上1位の値（℃）'], cmap='Reds')
plt.colorbar()
scatterはデータをプロットするマーカーの色の濃淡で表すこともできます。引数のs=はマーカーの大きさを指定していて，c=で色の濃淡を決める項目'昨日までの観測史上1位の値（℃）'を指定しています。また，cmap=で濃淡を出すための連続的に色の濃さが変化するカラーマップ'Reds'を指定しています。カラーマップの色には，青ベースのBlues，緑ベースのGreensなどを利用することができます。最後に，colorbar()によってグラフの右側に使っている色の濃淡がわかるカラーバーを表示しています。

演習）上と同様のプロットを気象庁の最低気温のCSVデータ (https://www.data.jma.go.jp/obd/stats/data/mdrr/tem_rct/alltable/mntemsadext00_rct.csv) を読み込んでプロットしてみましょう。

[ ]
  1
  2
  3
import pandas as pd
import matplotlib.pyplot as plt

20 COVID-19 のオープンデータの可視化
まず、東京都が出している新型コロナウイルスのデータをダウンロードし，分析する．

[ ]
  1
!wget --no-check-certificate --output-document=covid19_tokyo.json 'https://raw.githubusercontent.com/tokyo-metropolitan-gov/covid19/development/data/data.json'
データを'covid19_tokyo.json'という名前のjsonファイルとしてダウンロードしている．

[ ]
  1
  2
import pandas as pd
data1 = pd.read_json('covid19_tokyo.json')
pandasというライブラリをインポートする． pandasはデータ分析に便利なもので，簡単にデータの読み込みといった処理ができる． pd.read_jsonによってjsonファイルを読み込む．

[ ]
  1
data1.head(10)
data1.head(10)でdata1の最初10行を表示する． これでdata1がどのような形なのかを確認する． 今回は'inspection_persons'に検査実施回数，'patients_summary'に感染者数，'patients'に感染者の詳細が記録されていることがわかる．

練習1
このデータを用いて，日毎の感染者数を棒グラフで表す．

[ ]
  1
  2
#以下を実行してdata['patients_summary']['data']の最初の行を確認してみよ
data1['patients_summary']['data'][0]
[ ]
  1
  2
  3
  4
  5
  6
  7
#何が表示されるか予想してから以下を実行せよ
patients_data = []
patients_date_data = []
for i in range(len(data1['patients_summary']['data'])):
    patients_data.append(data1['patients_summary']['data'][i]['小計'])
    patients_date_data.append(data1['patients_summary']['data'][i]['日付'][5:10])
print(patients_date_data[0], patients_data[0])
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
#日付が横軸，感染者数が縦軸となるように棒グラフを作成する

#まず，matplotlibというライブラリをインポートする．これはグラフの描画をするためのものである．
import matplotlib.pyplot as plt
!pip install japanize-matplotlib
import japanize_matplotlib

# データを描画する
plt.figure(figsize=(20,12))
plt.bar(patients_date_data, patients_data)
plt.xticks(rotation=90)
plt.show()
21 地図とオープンデータの利用
自治体等が公開しているオープンデータを利用して、地図の上にマークを行うことができる。ここでは、文京区が公開している、AEDのCSV形式データを利用する。
今回は、以下のURLにでているCSVのアイコン（オレンジ色）から、データを入手することとして、CSVデータを直接入力できるURLを、プログラム中に記した。
https://catalog.data.metro.tokyo.lg.jp/dataset/t131059d0000000002
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
import folium
import pandas as pd

# csvからのデータ読み込み(必要なカラムだけを抽出)
df = pd.read_csv('https://www.city.bunkyo.lg.jp/library/opendata-bunkyo/05bousai-macidukuri-kankyou/11aedsettikasyoitiran/aedsettikasyoitiran.csv', usecols = ['名称','緯度','経度','設置台数'], encoding='sjis')

# 欠損値削除
df = df.dropna()

# 地図生成（東京都文京区中心）
folium_map = folium.Map(location=[35.72349, 139.749553], zoom_start=14)

# マーカープロット
for i, row in df.iterrows():

    count = row['設置台数']
    if count == 1:
            folium.Marker(
                location=[row['緯度'], row['経度']],
                popup=row['名称'],
                icon=folium.Icon(color='red')
            ).add_to(folium_map)
    else:
        folium.Marker(
            location=[row['緯度'], row['経度']],
            popup=row['名称'],
            icon=folium.Icon(color='blue')
        ).add_to(folium_map)

# 地図表示
folium_map
22 メルカトル図法地図を球体にする
NASAが配布している地球のメルカトル画像ファイルから、各点の色を取り出し、極座標変換を利用して立体的に見えるようにしたプログラム。
https://visibleearth.nasa.gov/images/73909/december-blue-marble-next-generation-w-topography-and-bathymetry
以下のサイトにあるものを Google Colaboratoryでも動くようにした。
http://memomemokun.hateblo.jp/entry/2018/12/27/182932
まずは、NASAからメルカトル図法の画像ファイルを入手する。

[ ]
  1
!wget https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg
そのファイルを利用して描画する。

[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
import matplotlib.pyplot as plt 
import numpy as np 
from mpl_toolkits.mplot3d import Axes3D 

def sphere_plot(image_file):
    img = plt.imread(image_file)
    
    # 画像を少し間引く
    img=img[::10,::10]
    
    # 球の球面座標　r:動径、θ:極角(天頂角)、φ：方位角(偏角)
    R = 1
    theta = np.linspace(0, np.pi, img.shape[0])
    phi = np.linspace(0, 2*np.pi, img.shape[1])

    # 球の球面座標 (r,θ,φ) を直交直線座標 (x,y,z) に変換
    x = R * np.outer(np.cos(phi), np.sin(theta))
    y = R * np.outer(np.sin(phi), np.sin(theta))
    z = R * np.outer(np.ones(np.size(phi)), np.cos(theta))

    # 球の表面をイメージファイルで塗りつぶして3Dで描画する
    fig = plt.figure(figsize=(10, 10)) 
    ax = fig.add_subplot(111, projection='3d') 
    plt.subplots_adjust(left=0, right=1, bottom=0, top=1)
    ax.plot_surface(x.T, y.T, z.T, rstride=1, cstride=1, facecolors = img/256.) 

    plt.savefig('1.jpg', dpi=72)
    plt.show()

if __name__ == "__main__":
    # 5400x2700
    image_file = 'world.topo.bathy.200412.3x5400x2700.jpg'
    sphere_plot(image_file)
解答編
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
import matplotlib.pyplot as plt # グラフプロットの呼び出し
r = int(input('radius? ')) # 円の半径、正方形の1辺の長さ
sr = r*r # 2乗計算は1回で済ませておく
incount = 0 # 円に入った点の数、初期値はゼロ

plt.figure(figsize=(5,5)) # 描画領域を正方形に
plt.xlim(-r, r) # x軸の範囲
plt.ylim(-r, r) # y軸の範囲

for u in range(-r, r):
  x=u+0.5
  sx = x*x # 2乗計算は1回で済ませておく
  for v in range(-r, r): 
    y=v+0.5
    if sx + y*y <= sr: # 半径r の円の中に入ったら
      incount += 1 # 入ったカウンターに 1 を加える
      plt.scatter(x, y, c="#000") # 黒でプロット
    else:
      plt.scatter(x, y, c="#ddd") # 灰色でプロット

p = incount / sr # 求まった円周率の近似値の計算
print(" 円周率 :", p ) # 近似値の表示
plt.title("lattice method") # グラフのタイトル
plt.show() # グラフの描画
[ ]
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
# マージソート

def msort(target):
  print("in ", target)
  l = len(target)
  if l < 2:
    print("out: ",target)
    return target
  else:
    mae = []
    ushiro = []
    r = []

    lmae = int( l / 2 )
    for i in range( lmae ):
      mae.append( target[ i ] )
    mae = msort( mae )

    for j in range( i+1, l ):
      ushiro.append( target[ j ] )
    ushiro = msort( ushiro )
    lushiro = l - lmae

    m = 0
    u = 0
    while m < lmae or u < lushiro :
      if m == lmae:
        r.append( ushiro[ u ] )
        u += 1
      elif u == lushiro:
        r.append( mae[ m ] )
        m += 1
      else:
        if mae[ m ] < ushiro[ u ]:
          r.append(mae[ m ])
          m += 1
        else:
          r.append(ushiro[ u ])
          u += 1
    print("out: ",r)
    return r

seq = [56,85,96,6,22,10,94,71,38,43,63]
print("Before: ", seq)

seq=msort(seq)
print("After: ", seq)
To undo cell deletion use Ctrl+M Z or the 'Undo' option in the 'Edit' menu
